#!/usr/bin/python3

import sys
import os
import subprocess
import shutil

from metrics import EOSMetrics

# JPRVITA: MVP in this project context means Minimum Viable Project, meaning
# that we are trying to keep this as simple as possible, and not trying to make
# a fully-featured piece of software. But it is not a great name for classes,
# repos or programs. Perhaps OfflineMetricsCollector instead?
class MVPCollector(EOSMetrics):

    def __init__(self, storage_path=None):
        super().__init__()
        if storage_path is None:
            '''
            TODO: Use dialog window instead
            '''
            # JPRVITA: let's have a full usage instead, before creating this
            # object (more on that together with parsing arguments)
            print('Please assign the metrics data storage path')
        else:
            # JPRVITA: if we are running from the USB device, can't we simply
            # automatically get this path here? os.getcwd() will give you the
            # current working directory
            self.offline_metrics_usbdisk_node = storage_path
        self.offline_metrics_dst_dir = 'eos-metrics-data-1'
        self.disk_free_space_in_bytes = 0
        self.offline_machine_data_dir = None

    def get_usbdisk_free_space(self):
        disk_usage = shutil.disk_usage(self.offline_metrics_usbdisk_node)
        self.disk_free_space_in_bytes = disk_usage.free
        return disk_usage.free

    def create_folder_for_machine(self):
        target_dir = os.path.join(self.offline_metrics_usbdisk_node, self.offline_metrics_dst_dir)
        if os.path.exists(target_dir) is False:
            os.mkdir(target_dir)

        if os.path.exists(self.tracking_id_path) is True:
            f = open(self.tracking_id_path)
            self.offline_machine_data_dir = os.path.join(target_dir, f.read(32))
            if os.path.exists(self.offline_machine_data_dir) is False:
                os.mkdir(self.offline_machine_data_dir)
            else:
                # JPRVITA: let's not remove this directory if it already
                # exists. If the user tries to extract the data two times in a
                # row, by error, all the data will be lost. You can simply
                # print an error here.
                subprocess.check_output(['rm', '-rf', self.offline_machine_data_dir])
            # JPRVITA: why are you creating the directory again in the line
            # below?
            os.mkdir(self.offline_machine_data_dir)
            f.close()
        elif os.path.exists(self.machine_id_path) is True:
            # JPRVITA: please don't duplicate this code block. You can try to
            # read an id from metrics_id or machine_id before trying to look
            # for or creating any directories, and have only one block with
            # open / mkdir (unless I am missing something here)
            f = open(self.machine_id_path)
            self.offline_machine_data_dir = os.path.join(target_dir, f.read(32))
            if os.path.exists(self.offline_machine_data_dir) is False:
                os.mkdir(self.offline_machine_data_dir)
            else:
                subprocess.check_output(['rm', '-rf', self.offline_machine_data_dir])
            os.mkdir(self.offline_machine_data_dir)
            f.close()
        else:
            print('There is no tracking/machine id available')

    # JPRVITA: why do we need to do this in a separate method? isn't is easier
    # to do it as part of create_folder_for_machine, where you already have the
    # tracking_id or machine_id?
    def copy_tracking_id(self):
        print(self.tracking_id_path)
        if os.path.exists(self.tracking_id_path) is True:
            # The tracking id file has permission -rwxrwsr-x  which
            # will raise PermissionError for shutil.copy, use copyfile
            # instead
            # JPRVITA: the comment above does not explain why we get this
            # permission error, which is because shutils.copy try to copy the
            # file permissions as well, and FAT32 does not support the
            # permissions from this file.
            shutil.copyfile(self.tracking_id_path, os.path.join(self.offline_machine_data_dir, os.path.basename(self.tracking_id_path)))
        elif os.path.exists(self.machine_id_path) is True:
            shutil.copyfile(self.machine_id_path, os.path.join(self.offline_machine_data_dir, os.path.basename(self.tracking_id_path)))
        else:
            printf('No tracking/machine id file found')

    def copy_metrics_data(self):
        # JPRVITA: you should stop the metrics daemon before copying the files,
        # to make it flush any pending data to disk and to guarantee the files
        # will not change while you are copying them.
        files = ['boot_offset_metafile', 'network_send_file', 'variants.dat', 'variants.dat.metadata']
        for file in files:
            shutil.copyfile(os.path.join(self.metrics_cache_dir, file), os.path.join(self.offline_machine_data_dir, os.path.basename(file)))

    def reset_metrics_data(self):
        if (self.get_service_state() == 0):	#active
            subprocess.check_output(['/usr/bin/systemctl', 'stop', self.systemd_service])
        files = ['variants.dat', 'variants.dat.metadata']
        for file in files:
            target_file = os.path.join(self.metrics_cache_dir, file)
            subprocess.check_output(['sudo', 'rm', '-f', target_file])
        subprocess.check_output(['/usr/bin/systemctl', 'start', self.systemd_service])

    def metrics_copy(self):
        self.create_folder_for_machine()
        self.copy_tracking_id()
        self.copy_metrics_data()


def main():
    # JPRVITA: if we are expecting command line arguments, let's put together a
    # familiar interface, including an usage description. This can be easily
    # done with python's argparse module:
    # https://docs.python.org/3/library/argparse.html
    location = os.path.dirname(os.path.realpath(sys.argv[0]))
    collector = MVPCollector(location)
    # JPRVITA: we should check if there is enought free space for the data we
    # are trying to copy, instead of using a pre-defined number
    if collector.get_usbdisk_free_space() > 10 * 1024 * 1024:
        collector.metrics_copy()
        print("Copy Done")
        collector.reset_metrics_data()
    else:
        print("Insufficient free USB space")

if __name__ == '__main__':
    main()

